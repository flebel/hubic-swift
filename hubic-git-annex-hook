#!/usr/bin/ruby
require 'rubygems'
require 'json'
require 'mechanize'
require 'dbus'

class SecretStore
  def byte_arr_to_s(arr)
    arr.inject("") do |sum,e| sum + e.chr end
  end

  def prompt (prompt,signal)
    if prompt == "/" then
      return
    end

    prompt_object = @dbus_service.object(prompt)
    prompt_object.introspect
    prompt_object.default_iface = "org.freedesktop.Secret.Prompt"
    main = DBus::Main.new()
    main << @bus
    dismiss=true
    prompt_object.on_signal(signal) do |u|
      dismiss = u
      main.quit()
    end
    prompt_object.Prompt("")
    main.run
    if dismiss
      exit(-1)
    end
    returm dismiss
  end

  def initialize
    @bus = DBus::SessionBus.instance
    @dbus_service = @bus.service("org.freedesktop.secrets")
    @main_object = @dbus_service.object("/org/freedesktop/secrets")
    @main_object.introspect
    @main_object.default_iface = "org.freedesktop.Secret.Service"
    
    @session = @main_object.OpenSession("plain","")[1]

    default_collection_name = @main_object.ReadAlias("default").first
    @default_collection = @dbus_service.object(default_collection_name)
    @default_collection.introspect
    @default_collection.default_iface = "org.freedesktop.Secret.Collection"
    
    prompt = @main_object.Unlock([default_collection_name])
    unlocked = prompt.first.first
    if unlocked.nil? 
      prompt(prompt[1],"Completed")
    end
  end

  def lookup_items(info)
    name = @default_collection.SearchItems("Service" => "Hubic", "Info" => info).first
    if name.first
      item=@dbus_service.object(name.first)
      item.introspect
      item.default_iface = "org.freedesktop.Secret.Item"
      return item
    end
  end

  def lookup_secret(info,public_info,private_info)
    item = lookup_items(info)

    unless item                 # There is no item, create it
      print "What is your #{public_info}: "
      pi = STDIN.readline.chomp
      # I failed to create it with dbus, so let cheat
      Process.wait(Process.spawn("secret-tool", "store", "--label=Hubic #{info}", "Service", "Hubic", "Info", info, public_info, pi))
      item = lookup_items(info)
    end
    
    unless item                 # This is not working
      exit(-1)                  # let die
    end

    [item["org.freedesktop.Secret.Item"]["Attributes"][public_info], byte_arr_to_s(item.GetSecret(@session).first[2])]
  end

  def lookup_connection_token
    item = lookup_items("tokens")
    return nil unless item
    JSON.load(byte_arr_to_s(item.GetSecret(@session).first[2]))
  end

  def store_connection_token(token)
    IO.popen(["secret-tool", "store", "--label=Hubic tokens", "Service", "Hubic", "Info", "tokens"],"r+") do |fd|
      fd.puts JSON.dump(token)
    end
  end

  def get_user_info 
    @username,@userpass = lookup_secret("user","username","password")
  end

  def username
    @username || get_user_info[0]
  end

  def userpass
    @userpass || get_user_info[1]
  end

  def get_client_info
    @client_id, @client_secret = lookup_secret("client","client_id","client_secret")
  end

  def client_id
    @client_id || get_client_info[0]
  end

  def client_secret
    @client_secret || get_client_info[1]
  end

  def creds_available?
    lookup_items("user") and lookup_items("client")
  end
end

TOKEN_URL = "https://api.hubic.com/oauth/token/"
AUTH_URL = "https://api.hubic.com/oauth/auth"
REDIRECT_URI = "https://localhost.localdomain:4090/"
CREDENTIALS_URL="https://api.hubic.com/1.0/account/credentials"

class HubicInterface
  def initialize(secret_store)
    @secret_store=secret_store
  end
  
  def agent 
    unless @agent
      @agent = Mechanize.new
      @agent.redirect_ok=false
    end
    @agent
  end

  def connect!
    @token = @secret_store.lookup_connection_token
    connect_to_hubic unless @token # If no token, we must connect to hubic
    if @token["expires"] then
      if Time.now >  Time.utc(@token["expires"][0],@token["expires"][1],@token["expires"][2],@token["expires"][3]) then
        refresh_hubic_token
        connect_to_os
        @secret_store.store_connection_token(@token)
      end
    else
      connect_to_os
      @secret_store.store_connection_token(@token)
    end    
  end

  def connect_to_hubic
    warn 'connect hubic'
    page = agent.get(AUTH_URL,{ "client_id" => @secret_store.client_id,
                       "redirect_uri" => REDIRECT_URI,
                       "scope" => "usage.r,account.r,getAllLinks.r,credentials.r,links.drw",
                       "response_type" => "code",
                       "state" => "none"
                     },nil,nil)
    page=page.links.first.click
    form = page.forms.first
    form['login']=@secret_store.username
    form['user_pwd']=@secret_store.userpass
    page2=form.click_button
    response_url=page2["location"]
    exit(-1) unless response_url

    @code = response_url.scan(/code=[^&]*/).first[5..-1]
    exit(-1) unless @code
    
    @base64cred = Base64.encode64("#{@secret_store.client_id}:#{@secret_store.client_secret}").gsub(/\n/, '')
    response=agent.post(TOKEN_URL,{ "code"=>@code, "redirect_uri"=>REDIRECT_URI, "grant_type"=>"authorization_code"}, 
                        { "Authorization" => "Basic #{@base64cred}" })
    @token = JSON.load(response.body)
    @token['code']=@code
    return @token
  end

  def refresh_hubic_token
    warn 'refresh hubic'
    response=agent.post(TOKEN_URL,{ "refresh_token" => @token['refresh_token'], "grant_type"=>"refresh_token", "client_id"=>@secret_store.client_id, "client_secret" => @secret_store.client_secret })
    new_token = JSON.load(response.body)
    @token.merge!(new_token)
  end

  def connect_to_os
    warn 'connect_to_os'
    response=agent.get(CREDENTIALS_URL,parameters={},referer=nil,header = { "Authorization" => "Bearer #{@token["access_token"]}" })
    new_token = JSON.load(response.body)
    new_token["expires"]=new_token["expires"].scan(/[0-9]+/).map { |s| s.to_i }
    @token.merge!(new_token)
  end

  def endpoint
    @endpoint ||= @token['endpoint']
  end

  def os_token
    @os_token ||= @token['token']
  end

  def container(container)
    @container = container
    response=agent.put("#{endpoint}/#{container}",'',"X-Auth-Token" => os_token)
    exit (-1) unless response.code[0] == 2 # Let die if we don't have 2?? response
    self
  end

  def store(path,file)
    file=File.open(file,'rb')
    response=agent.put("#{endpoint}/#{container}/#{Mechanize::Util::uri_escape(path)}",file,"X-Auth-Token" => os_token)
    exit (-1) unless response.code == "201" # Let die if we don't have "201 created" response
    file.close
  end

  def get(path,file)
    agent.pluggable_parser.default = Mechanize::Download
    response=agent.get("#{endpoint}/#{container}/#{Mechanize::Util::uri_escape(path)}",file,"X-Auth-Token" => os_token)
    exit (-1) unless response.code == "200" # Let die if we don't have the "200" response
    response.save!(file)
  end
end  

class GitAnnexHook
  def initialize(secret,hubic)
    @secret_store = secret
    @hubic = hubic
  end
  
  def init
    @secret_store.username
    @secret_store.userpass
    @secret_store.client_id
    @secret_store.client_secret
  end

  def store(container,hash1, hash2, key,file)
    hubic.container(container).store("#{hash1}/#{hash2}/#{key}",file)
  end

  def get(container,hash1, hash2, key,file)
    hubic.container(container).get("#{hash1}/#{hash2}/#{key}",file)
  end

  def dispatch(container)
    action = ENV['ANNEX_ACTION']
    if action == "store" then
      store(container,ENV['ANNEX_HASH_1'],ENV['ANNEX_HASH_2'],ENV['ANNEX_KEY'],ENV['ANNEX_FILE'])
    elsif action == "retrieve" then
      get(container,ENV['ANNEX_HASH_1'],ENV['ANNEX_HASH_2'],ENV['ANNEX_KEY'],ENV['ANNEX_FILE'])
    elsif  action == "remove" then
      exit(-1) #NOT IMPLEMENTED demo-nuke "$ANNEX_HASH_1/$ANNEX_HASH_2/$ANNEX_KEY"
    elsif ENV['ANNEX_ACTION'] == "checkpresent" then
      exit(-1) #    if demo-exists "$ANNEX_HASH_1/$ANNEX_HASH_2/$ANNEX_KEY"; then
               #       echo "$ANNEX_KEY"
               #    fi
    end
  end
end

def main
  secret_store=SecretStore.new
  hubic=HubicInterface.new(secret_store)
  hook = GitAnnexHook.new(secret_store,hubic)
  if ARGV.first=="--init" then
    hook.init
    exit(0)
  elsif ARGV.first=="--help" then
    warn "This is a git annex remote hook, that should no be run directly,"
    warn "but mainly as a specila remote hook, see git annex doc"
    warn "you can still run it with the `--init` option to store your cred in your gnome-keyring or kwallet"
    warn "or with --clean-connexion-token and --clean-creds to remove some information from them"
    exit(0)
  elsif ARGV.first == "--clean-connexion-token" then
    secret_store.clean-connexion-token # TODO
    exit(0)
  elsif ARGV.first == "--clean-creds" then
    secret_store.clean-creds    # TODO
    exit(0)
  end

  if ENV['ANNEX_ACTION'].nil? then
    warn "I don\'t now what to do"
    warn "Either run with --init to store credetianle in your gnome-keyring or kwallet"
    warn "or run it as special remote hook"
    warn "see http://git-annex.branchable.com/special_remotes/hook/"
    exit(-1)
  elsif ARGV.first.nil? then
    warn "first argument of the hook should be the name of the container"
    warn "bye default hubic have only one container named default"
    warn "this hook will create the container if it do no exist"
    exit(-1)
  elsif not(secret_store.creds_available?) then
    exit(-1)
  end

  hubic.connect!
  
  hook.dispatch!(ARGV.first)
  
end

main
