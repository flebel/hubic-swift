#!/usr/bin/ruby
require 'rubygems'
require 'json'
require 'mechanize'
require 'dbus'

class SecretStore
  def byte_arr_to_s(arr)
    arr.inject("") do |sum,e| sum + e.chr end
  end

  def prompt (prompt,signal)
    if prompt == "/" then
      return
    end

    prompt_object = @dbus_service.object(prompt)
    prompt_object.introspect
    prompt_object.default_iface = "org.freedesktop.Secret.Prompt"
    main = DBus::Main.new()
    main << @bus
    dismiss=true
    prompt_object.on_signal(signal) do |u|
      dismiss = u
      main.quit()
    end
    prompt_object.Prompt("")
    main.run
    if dismiss
      exit(-5)
    end
    return dismiss
  end

  def initialize
    @bus = DBus::SessionBus.instance
    @dbus_service = @bus.service("org.freedesktop.secrets")
    @main_object = @dbus_service.object("/org/freedesktop/secrets")
    @main_object.introspect
    @main_object.default_iface = "org.freedesktop.Secret.Service"

    @session = @main_object.OpenSession("plain","")[1]

    default_collection_name = @main_object.ReadAlias("default").first
    @default_collection = @dbus_service.object(default_collection_name)
    @default_collection.introspect
    @default_collection.default_iface = "org.freedesktop.Secret.Collection"

    prompt = @main_object.Unlock([default_collection_name])
    unlocked = prompt.first.first
    if unlocked.nil?
      prompt(prompt[1],"Completed")
    end
  end

  def lookup_items(info)
    name = @default_collection.SearchItems("Service" => "Hubic", "Info" => info).first
    if name.first
      item=@dbus_service.object(name.first)
      item.introspect
      item.default_iface = "org.freedesktop.Secret.Item"
      return item
    end
  end

  def lookup_secret(info,public_info,private_info)
    item = lookup_items(info)

    unless item                 # There is no item, create it
      print "What is your #{public_info}: "
      pi = STDIN.readline.chomp
      # I failed to create it with dbus, so let cheat
      Process.wait(Process.spawn("secret-tool", "store", "--label=Hubic #{info}", "Service", "Hubic", "Info", info, public_info, pi))
      item = lookup_items(info)
    end

    unless item                 # This is not working
      exit(-6)                  # let die
    end

    [item["org.freedesktop.Secret.Item"]["Attributes"][public_info], byte_arr_to_s(item.GetSecret(@session).first[2])]
  end

  def lookup_connection_token
    item = lookup_items("tokens")
    return nil unless item
    JSON.load(byte_arr_to_s(item.GetSecret(@session).first[2]))
  end

  def store_connection_token(token)
    IO.popen(["secret-tool", "store", "--label=Hubic tokens", "Service", "Hubic", "Info", "tokens"],"r+") do |fd|
      fd.puts JSON.dump(token)
    end
  end

  def get_user_info
    @username,@userpass = lookup_secret("user","username","password")
  end

  def username
    @username || get_user_info[0]
  end

  def userpass
    @userpass || get_user_info[1]
  end

  def get_client_info
    @client_id, @client_secret = lookup_secret("client","client_id","client_secret")
  end

  def client_id
    @client_id || get_client_info[0]
  end

  def client_secret
    @client_secret || get_client_info[1]
  end

  def creds_available?
    lookup_items("user") and lookup_items("client")
  end

  def clean_connexion_token
    item = lookup_items("tokens")
    item.Delete
  end
end

TOKEN_URL = "https://api.hubic.com/oauth/token/"
AUTH_URL = "https://api.hubic.com/oauth/auth"
REDIRECT_URI = "https://localhost.localdomain:4090/"
CREDENTIALS_URL="https://api.hubic.com/1.0/account/credentials"

class HubicInterface
  def initialize(secret_store)
    @secret_store=secret_store
  end

  def agent
    unless @agent
      @agent = Mechanize.new
      @agent.redirect_ok=false
    end
    @agent
  end

  def connect!
    @token = @secret_store.lookup_connection_token
    connect_to_hubic unless @token # If no token, we must connect to hubic
    if @token["expires"] then
      if Time.now >  Time.utc(@token["expires"][0],@token["expires"][1],@token["expires"][2],@token["expires"][3]) then
        refresh_hubic_token
        connect_to_os
        @secret_store.store_connection_token(@token)
      end
    else
      connect_to_os
      @secret_store.store_connection_token(@token)
    end
  end

  def connect_to_hubic
    warn 'connect hubic'
    page = agent.get(AUTH_URL,{ "client_id" => @secret_store.client_id,
                       "redirect_uri" => REDIRECT_URI,
                       "scope" => "usage.r,account.r,getAllLinks.r,credentials.r,links.drw",
                       "response_type" => "code",
                       "state" => "none"
                     },nil,nil)
    page=page.links.first.click
    form = page.forms.first
    form['login']=@secret_store.username
    form['user_pwd']=@secret_store.userpass
    page2=form.click_button
    response_url=page2["location"]
    exit(-7) unless response_url

    @code = response_url.scan(/code=[^&]*/).first[5..-1]
    unless @code
      warn response_url
      exit(-8)
    end

    @base64cred = Base64.encode64("#{@secret_store.client_id}:#{@secret_store.client_secret}").gsub(/\n/, '')
    response=agent.post(TOKEN_URL,{ "code"=>@code, "redirect_uri"=>REDIRECT_URI, "grant_type"=>"authorization_code"},
                        { "Authorization" => "Basic #{@base64cred}" })
    @token = JSON.load(response.body)
    @token['code']=@code
    return @token
  end

  def refresh_hubic_token
    warn 'refresh hubic'
    response=agent.post(TOKEN_URL,{ "refresh_token" => @token['refresh_token'], "grant_type"=>"refresh_token", "client_id"=>@secret_store.client_id, "client_secret" => @secret_store.client_secret })
    new_token = JSON.load(response.body)
    @token.merge!(new_token)
    @secret_store.store_connection_token(@token)
    @token
  end

  def connect_to_os
    warn 'connect_to_os'
    response=agent.get(CREDENTIALS_URL,parameters={},referer=nil,header = { "Authorization" => "Bearer #{@token["access_token"]}" })
    new_token = JSON.load(response.body)
    new_token["expires"]=new_token["expires"].scan(/[0-9]+/).map { |s| s.to_i }
    @token.merge!(new_token)
    @secret_store.store_connection_token(@token)
    @token
  end

  def endpoint
    @token['endpoint']
  end

  def os_token
    @token['token']
  end

  def container(container)
    @container = container
    response=agent.put("#{endpoint}/#{@container}",'',"X-Auth-Token" => os_token)
    exit (-1) unless response.code[0] == '2' # Let die if we don't have 2?? response
    self
  end

  def try_or_reconnect          # It can yield severall time the block
    yield                       # We try
  rescue Net::HTTPUnauthorized => e
    begin
      refresh_hubic_token       # We then try to refresh
      yield
    rescue Net::HTTPUnauthorized => e
      @secret_store.clean_connexion_token
      connect!
      yield
    end
  end

  def set_body_stream file, agent, request
    request.body_stream = file
  end

  def store(path,file)
    file=File.open(file,'rb')
    # Mechanize don't do file upload on streem
    hook = lambda {|agent, request| set_body_stream file, agent, request }
    @agent.pre_connect_hooks.push hook
    response=agent.put("#{endpoint}/#{@container}/#{Mechanize::Util::uri_escape(path)}",file,"X-Auth-Token" => os_token)
    @agent.pre_connect_hooks.pop
    exit (-1) unless response.code == "201" # Let die if we don't have "201 created" response
    file.close
  end

  def get(path,file)
    agent.pluggable_parser.default = Mechanize::Download
    response=agent.get("#{endpoint}/#{@container}/#{Mechanize::Util::uri_escape(path)}",{},nil,"X-Auth-Token" => os_token)
    exit (-11) unless response.code == "200" # Let die if we don't have the "200" response
    response.save!(file)
  end

  def delete(path)
    response=agent.delete("#{endpoint}/#{@container}/#{Mechanize::Util::uri_escape(path)}",{},"X-Auth-Token" => os_token)
    exit (-12) unless response.code == "204" # Let die if we don't have the "200" response
  end

  def head(path)
    response=agent.head("#{endpoint}/#{@container}/#{Mechanize::Util::uri_escape(path)}",{},"X-Auth-Token" => os_token)
    response.code=="200"
  rescue Mechanize::ResponseCodeError => e
    false
  end
end

class GitAnnexHook
  def initialize(secret,hubic)
    @secret_store = secret
    @hubic = hubic
  end

  attr_reader :hubic

  def init
    @secret_store.username
    @secret_store.userpass
    @secret_store.client_id
    @secret_store.client_secret
  end

  def store(container,hash1, hash2, key,file)
    hubic.container(container).store("#{hash1}/#{hash2}/#{key}",file)
  end

  def get(container,hash1, hash2, key,file)
    hubic.container(container).get("#{hash1}/#{hash2}/#{key}",file)
  end

  def remove(container,hash1, hash2, key)
    hubic.container(container).delete("#{hash1}/#{hash2}/#{key}")
  end

  def checkpresent(container,hash1, hash2, key)
    if hubic.container(container).head("#{hash1}/#{hash2}/#{key}") then
      print(key)
    end
  end

  def dispatch(container)
    action = ENV['ANNEX_ACTION']
    if action == "store" then
      store(container,ENV['ANNEX_HASH_1'],ENV['ANNEX_HASH_2'],ENV['ANNEX_KEY'],ENV['ANNEX_FILE'])
    elsif action == "retrieve" then
      get(container,ENV['ANNEX_HASH_1'],ENV['ANNEX_HASH_2'],ENV['ANNEX_KEY'],ENV['ANNEX_FILE'])
    elsif  action == "remove" then
      remove(container,ENV['ANNEX_HASH_1'],ENV['ANNEX_HASH_2'],ENV['ANNEX_KEY'])
    elsif action == "checkpresent" then
      checkpresent(container,ENV['ANNEX_HASH_1'],ENV['ANNEX_HASH_2'],ENV['ANNEX_KEY'])
    end
  end
end

def main
  secret_store=SecretStore.new
  hubic=HubicInterface.new(secret_store)
  hook = GitAnnexHook.new(secret_store,hubic)
  if ARGV.first=="--init" then
    hook.init
    exit(0)
  elsif ARGV.first=="--help" then
    warn "This is a git annex remote hook, that should no be run directly,"
    warn "but mainly as a specila remote hook, see git annex doc"
    warn "you can still run it with the `--init` option to store your cred in your gnome-keyring or kwallet"
    warn "or with --clean-connexion-token and --clean-creds to remove some information from them"
    exit(0)
  elsif ARGV.first == "--clean-connexion-token" then
    secret_store.clean_connexion_token # TODO
    exit(0)
  elsif ARGV.first == "--clean-creds" then
    secret_store.clean-creds    # TODO
    exit(0)
  end

  if ENV['ANNEX_ACTION'].nil? then
    warn "I don\'t now what to do"
    warn "Either run with --init to store credetianle in your gnome-keyring or kwallet"
    warn "or run it as special remote hook"
    warn "see http://git-annex.branchable.com/special_remotes/hook/"
    exit(-2)
  elsif ARGV.first.nil? then
    warn "first argument of the hook should be the name of the container"
    warn "bye default hubic have only one container named default"
    warn "this hook will create the container if it do no exist"
    exit(-3)
  elsif not(secret_store.creds_available?) then
    exit(-4)
  end

  hubic.connect!

  hook.dispatch(ARGV.first)
end

main
